# Why Immutable？
2016/11/01 22:30:00


这几年「函数式编程」被炒得很热，「函数式」这个概念到底怎么定义的存在很多争议，但没有争议的是，今天人们只要讲到它，总是会跟「不可变」这个概念扯到一起。


## 排序函数引发的故事

昨天，一个[V8引擎的BUG][v8]导致我得自己手写排序程序。排序程序于我而言，是写完就忘的东西。所以我去网上搜了一个JS的快排函数直接用。结果出了问题。

问题出得很隐蔽，我是过了好久，发现页面上的元素慢慢一点一点减少才注意到它的存在。又花了好一会儿功夫，才找到问题：排序函数有问题。

程序是[这里][sort]找到的，作者是一个好人，写了不少好文，但是他使用的那个程序对于JS而言，是不太好的。


## 哪里不好？

我们使用那个排序函数来做个测试

```js
var a = [1, 2, 3, 2, 1]
quickSort(a)
//=> Array [ 1, 1, 2, 2, 3 ]
```

结果正确，但是你在查看下此时的`a`

```js
a
//=> Array [ 1, 2, 2, 1 ]
```

少了一个元素。我们多运行几次之后，`a`成了空数组了。


## 头疼的传引用

那个排序函数的问题，是由`Array.prototype.splice`直接导致的。然而，深究一下，也可以归结为Javascript，以及大多数语言的特性：参数传递是传引用，而不是传拷贝。

相比「传引用」，「传拷贝」更易掌控，因为它能达到隔离的效果。但由于性能原因，一般只对整数「传拷贝」，而负责了绝大多数工作的「数据结构」，传引用。


## Immutable

性能问题是现今无法解决的，那怎么办呢？「Immutable」就是一个可行的解决办法。

只要被传递的对象都是Immutable的，你就可以放心地使用第三方代码。它依旧是传引用，只是你不能修改那个引用指向的对象了，所以调用者是安全的。


## 笨重

其实我并不很喜欢Immutable。去年有段时间使用Erlang，感觉像穿着笨重的铠甲，不用担心背后的冷箭，但跑起来费劲。那时偶尔写前端，Javascript用在手上有种飞的感觉。

当然这可以归咎为我的Erlang功底不够，如果我写上几年Erlang代码，可能就不会有这种感觉吧。

不管怎么说，Immutable从根源上规避了上面那种诡异的bug。这个在使用第三方库的时候尤为重要。


## 不要纯Immutable

其实Clojure给出了一个不错的主意。在Clojure里，你可以使用可变对象，但是需要特殊的函数，特殊的操作方法。就像传统语言里面，需要通过特殊办法定义出「不可变」对象一样。

所以区别变成了「默认可变」和「默认不可变」。

我觉得这是种比较舒服的做法。


[v8]: /2016/10/31/11.12.md 
[sort]: http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html
