# JS的回调，不同于MCU的中断
2016/11/08 19:47:00


曾有一位做单片机开发的朋友问我回调是怎么回事，我解释就跟单片机的中断函数类似，比如你的定时器的溢出值设置为200毫秒，那么单片机内部电路每200毫秒，就会把PC设置成你的定时器中断向量入口，达到调用中断程序的目的。在浏览器上，JS回调函数就相当于ISR。

后来发现这种说法有问题，只是我当时对Javascript的特性不是很了解。

表面上看它很恰当，但是却忽略了一些重要的问题。MCU的中断，是那种会直接打断程序流程的东西，而Javascript的回调，会很绅士地一直等下去。


## MCU是怎样的？

还是说「定时器中断」，当定时器的计数溢出或达到阈值，就会改变内部一个标志位。正在运行的指令执行完后，标志被检测到，这个中断就会被处理。

不同的MCU会有不同的处理方式。但大致原则是：
- 除非正在处理更高优先级的中断，否则立即响应定时器中断，调用中断处理子程序。
- 当正处在其他不可打断的中断（可能是优先级高，也可能是CPU本来就不支持打断），那么就等着，那个一完，这个就立即响应。

也就是说，基本上MCU会立即响应！


## 小心翼翼

单片机工程师在这一块会非常小心，举个例子，当MCU字长小于数据的字长，比如在8位机上使用int，如果这个值碰巧也会被ISR修改，就需要在处理int前，先关掉全局中断，处理完了重新打开。因为你不知道什么时候中断会产生并打断你。

软件开发人员编写多线程程序时，经常需要「加锁」，追究其根源，也是因为线程是会被「打断」的。进一步追究下去，其实操作系统实现线程或进程调度，本身就依赖于CPU的「中断」。

没错，「中断」就是祸根。


## Javascript是怎样的？

我们拿JS的setTimeOut来做个实验。（正好和定时器中断做个对比）

```js
setTimeout(() => console.log("cool"), 1000)
```

这个会在1秒钟后，打印出一个“cool”。一切在预期中，与「MCU中断」行为类似。

接下来我们定义一个函数，通过死循环来达到延时的效果。

```js
function sleepSync(ms) {
  var mark = new Date().getTime()
  while (new Date().getTime() - mark < 4000)
}
```

我们再来使用`setTimeout`，这次使用`sleepSync`进行延时。

```js
setTimeout(() => console.log("cool"), 1000)
sleepSync(4000)
```

出问题了，过了4秒之后才打印出“cool”。setTimeout并不能打断那个`while`循环。


## Node.js上呢？

我们在Node.js做另外一个实验，假设`/tmp/blah`是一个不存在的文件

```js
fs.readFile("/tmp/blah", (e, _) => console.log(e.message))
sleepSync(4000)
```

同样是过了4秒，才打印出

```
ENOENT: no such file or directory, open '/tmp/blah'
```

所以说不是浏览器的问题，而是JS的特性，任何JS环境下都是这样的。


## 只是相似而已

JS的「回调」和「MCU的中断」，是不能等同的，它们有一些相似点，但是在关键的地方不太一样，所以以后还是不要打这个比方吧。

至于Javascript为什么是这个样子，这跟Javascript的`Event Loop`和`task queue`有关了，但那是另外一个主题（如果感兴趣，请看[另一篇博客][eventloop]），这篇文章只是纠正一下过去自以为很棒的比喻。

[eventloop]: /2016/11/21/13.18.html
