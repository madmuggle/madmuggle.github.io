# C语言的结构体初始化没那么糟糕



## 和Go语言的对比

这几天看了很多Go语言相关的东西，对它的数组和结构体印象深刻。它们和C语言中的对应概念，在内存布局上完全相同，但是语法上要舒服且方便很多。

Go的数组，长度是类型的一部分。在Go语言里，`[3]int`和`[4]int`是两种不同的类型。

这种区分有很大好处，因为编译器能直接通过“类型”知道变量的空间大小，所以可以在语法上支持用`=`拷贝数组。

C对数组的处理比较粗糙，基本上是作为“指针常量”来对待的。你不可能在C里面，用`=`进行数组拷贝。

然而在“结构体”上，C却做得很细致，用法上并不比Go语言麻烦。当然这也跟结构体本身的特性相关。

结构体的初始化，赋值在C语言里面，都有着语法级别的支持。举个例子，先定义一个结构体：

```c
struct Myobj { char name[10]; int age; };
```

然后你可以这样定义并初始化一个结构体：

```c
struct Myobj me = {"madmuggle", 26};
```

跟Go有点像，如果按字符数来算，比Go还要简洁。另一方面，你可以用`=`进行结构体的赋值，和在Go语言里面一样：

```c
struct Myobj he = me;
```

赋值完成了，可以打印验证：

```c
printf("me: %d, he: %d\n", &me, &he);
PrintsMyobj(&me);
PrintsMyobj(&he);
```

输出结果是：

```
me: 1486392008, he: 1486391992
madmuggle: 26
madmuggle: 26
```

内容相同，地址不同，赋值成功。


## 两种情况

对于C的结构体初始化，在直接传入字符串字面量的时候，其实是有两种情况的，一是针对结构体的指针field，一是数组field。

上例中的结构体就是“数组field”的情况，如果对结构体做一点修改，就成了“指针field”：
```c
struct Myobj { char *name; int age; };
```

在这种情况下，结构体的初始化语法是不是还能够使用呢？

答案是依旧可以。修改运行一下发现结果如常。但是既然用了C，自然忍不住进一步探究背后的东西。

我们先编写一个用于打印内存中内容的函数`Printraw`方便之后测试：

```c
void Printraw(unsigned char *p, int size) {
   while (size--) printf("%02X ", *p++);
   printf("\n");
}
```

然后针对两种结构体形式运行：

```c
Printraw((unsigned char *)&me, sizeof(struct Myobj));
```

得到的输出分别是

char \*name:

```
A2 9F 11 0B 01 00 00 00 1A 00 00 00 00 00 00 00
```

char name[10]:

```
6D 61 64 6D 75 67 67 6C 65 00 00 00 1A 00 00 00
```

可以看出针对不同的情况，结构体的初始化语法做了不同的事情，但最终都达到了我们想要的效果。（位置的变化是为了CPU内存对齐）

所以以后喷C的数组就行了，别带上结构体。不要伤及无辜。

