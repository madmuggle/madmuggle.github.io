# Go语言拥有全功能的指针
2017/01/11 20:54:44
Go


## C指针的妙用

嵌入式开发有时需要直接访问固定地址的内存，因为单片机的内存和功能寄存器通常在同一个地址空间。但是编程语言很难直接操作特定地址的内存。

汇编语言是个例外，C语言是个例外，今天发现Go语言也是个例外。

C语言允许你做非常灵活的类型转换，并且配合指针来实现这一点。假设有一个16位的ADC寄存器的地址是0xabcd，要读取当前电压值，只需这样：

```c
uint16_t a = *(uint16_t *)0xabcd;
```


## Go的指针

我之前一直听说Go语言对指针做了限制，无法进行复杂的指针操作。其实它只是让你无法轻易地做那些事，却并没有“禁止”它。

比如上面那个读取ADC寄存器的任务，Go语言也是能够完成的：
```go
a := *(*uint16)(unsafe.Pointer(uintptr(0xabcd)))
```

比C做这种事要麻烦些，但毕竟还是可以做！


## 细节对比

首先是类型转换的语法不同。在C语言里面，类型转换是这种形式：

```c
(mytype) myvar
```

而在Go语言里面，是这种形式：

```go
mytype(myvar)
```

只不过如果要转换的目标类型是指针，就得写成这样：

```go
(*mytype)(myvar)
```

但变量`myvar`肯定是必须作为“参数”放在括号里的。

语法上的不同还是小事，Go对类型的检查非常严格，所以直接套用C的表达方式是会报错的：

```go
a := *(uint16)(0xabcd)
```

编译就会报错，类型不匹配：

```
cannot convert 43981 (type int) to type *uint32
```

将“整数”和“指针”关联起来的桥梁，是一个特殊的类型`uintptr`。这个类型和`unsafe.Pointer`结合起来，就形成了全功能的指针。


## uintptr

先获取一个指针，它指向的是一个byte数组，数组里面存了三个元素：0xaa,0xbb,0xcc

```go
b := unsafe.Pointer(&[3]byte{0xaa, 0xbb, 0xcc})
```

然后我们通过指针操作来获取它指向的内容：

```go
fmt.Println(*(*byte)(b))
//=> 170
```

甚至指针运算也是可以进行的：

```go
fmt.Println(*(*byte)(unsafe.Pointer(uintptr(b) + 1)))
//=> 187
```

```go
fmt.Println(*(*byte)(unsafe.Pointer(uintptr(b) + 2)))
//=> 204
```

所以Go不仅拥有和C一样底层的数组和结构体，而且拥有和C一样强大的指针。

