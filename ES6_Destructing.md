# ES6的解构 vs 模式匹配
2016/11/16 09:59:00
Javascript, Erlang


函数式编程语言里面，通常都有一种名曰「模式匹配」的特性。这玩意儿用来检验数据，或者提取数据的时候非常方便。不仅易用，而且简洁直观，是少有的美貌与智慧共存的东西。


## Erlang的模式匹配

Erlang的任何数据结构都可以使用模式匹配，比如最常用的列表

```erlang
[A, 2, [B, 4]] = [1, 2, [3, 4]].
%=> [1,2,[3,4]]
A.
%=> 1
B.
%=> 3
```

还有元组

```erlang
{A, 2, {B, 4}} = {1, 2, {3, 4}}.
%=> {1,2,{3,4}}
A.
%=> 1
B.
%=> 3
```

Erlang1.7加入的map也支持

```erlang
#{ping := A, key := B} = #{ping => pong, key => val}.
%=> #{key => val,ping => pong}
A.
%=> pong
B.
%=> val
```


模式匹配的两边必须完全对等，否则就会报错，因为它们“不匹配”

```erlang
[A, 9, [B, 4]] = [1, 2, [3, 4]].
%=> ** exception error: no match of right hand side value [1,2,[3,4]]
```


## ES6数组

我们来尝试用同样的用法来测试ES6数组的「解构」

```js
var [a, 2, [b, 4]] = [1, 2, [3, 4]]
```

在语法上这个都是不允许的，你会直接得到这样的错误信息

```
Uncaught SyntaxError: Unexpected number
```

或者这样的

```
SyntaxError: missing variable name
```

我们退一步，放弃对等的约束，用一个变量来占位

```js
var [a, _, [b, _]] = [1, 2, [3, 4]]
a
//=> 1
b
//=> 3
```

可行。ES6还支持更特殊的语法：直接留空

```js
var [a, , [b, ]] = [1, 2, [3, 4]]
```

虽说相比「模式匹配」功能上弱了一些，但总体上还是很相似的。



## ES6对象

ES6在「对象」的解构上，和函数式编程语言的「模式匹配」用法一致。（发自内心一个赞）

```js
var {a: x, t: {b: y}} = {a: 1, t: {b: 2}}
x
//=> 1
y
//=> 2
```

但是大家一般不会这样使用，最容易看到的用法其实是这样的

```js
var {a, b} = {a: 1, b: 2}
a
//=> 1
b
//=> 2
```

我第一次看到这种用法觉得很别扭和疑惑，因为它和模式匹配相似，但是规则又不同，而且这样的写法是无法支持嵌套对象的。直到我发现，在ES6里面，有这么一种语法来创建对象

```js
var a = 1, b = 2
var x = {a, b}
x
//=> { a: 1, b: 2 }
```

看这种语法后，就知道为什么ES6的解构，在「对象」上面做成那种形式了。某种程度上，这其实保证了一致性。

这种语法带来的典型好处，是使用Node.js时，可以不必在最后面写

```js
module.exports = {myFunc1: myFunc1, myFunc2: myFunc2}
```

而是潇洒的写下

```js
module.exports = {myFunc1, myFunc2}
```


## Tips

ES6的数组解构甚至可以用在`for...of`循环上面

```js
for (var [a, [b]] of [[1, [2]], [3, [4]]])
  console.log(a, b)
//  1 2
//  3 4
//=> undefined
```
